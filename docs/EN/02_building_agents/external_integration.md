# External Integration and I/O Boundaries (Aligned with Current Implementation)

This page describes how to connect external systems to CommonGround (scripts/services/tools). The following conventions are based on the current repository implementation:
- Default protocol version is `v1r3` (`core/config_defaults.py`).
- NATS and management APIs are **directly ingestible**, with no extra gateway layer.

> This page mainly explains how to connect integrations, not how to define tool protocols. See `creating_tools.md` for the tool development workflow.

## 1. Dependencies and Installation (Current)

`CommonGround` is still a mono-repo codebase, but exposes two Python package entry points: `core` and `infra` under `core/infra`.

- `core`: UTP data models, subject specifications, error and header definitions
- `infra`: NATS, CardBox, tool execution, and foundational service wrappers

Minimal local development install (aligned with repository `pyproject.toml`):

```bash
uv init my-consumer
cd my-consumer

uv add --editable ../CommonGround
uv add card-box-core
```

For "pure script calls" without running services, you can still import `from infra...` and `from core...` directly in scripts.

## 2. Configuration Loading (Consistent with Services)

All external entry points should use:

- `load_app_config()` (`core.app_config`)
- `config_to_dict(load_app_config())` (`core.app_config`)
- `service_cfg = cfg.get("nats")` / `service_cfg = cfg.get("cardbox")`

Configuration priority order is: `config.toml` â†’ environment variable overrides.

Environment overrides support both forms:

- New: `CG__SECTION__KEY=...` (JSON values supported)
  - e.g. `CG__NATS__SERVERS='["nats://localhost:4222"]`
- Backward compatible: `PG_DSN`, `NATS_SERVERS`

Example:

```bash
export CG_CONFIG_TOML=/path/to/config.toml
export CG__NATS__SERVERS='["nats://nats:4222"]'
export CG__NATS__TLS_ENABLED=false
export PG_DSN="postgresql://postgres:postgres@postgres:5432/cardbox"
```

See `core/config_defaults.py` for default config. Key fields include:

- `protocol.version`: default `v1r3`
- `nats.servers`, `nats.tls_enabled`, `nats.cert_dir`
- `cardbox.postgres_dsn`, `cardbox.tenant_id`, `cardbox.postgres_min_size`, `cardbox.postgres_max_size`
- `api.listen_host`, `api.port`

## 3. External I/O Boundaries Overview

## 3.1 Management API (HTTP)

Management APIs are implemented in `services/api/main.py`. Start with:

```bash
uv run -m services.api
```

Default listen address is `127.0.0.1:8099` (local development). For Docker deployment, set/override `api.listen_host` in `config.docker.toml` or config file.

### CORS policy

By default, API CORS is intentionally restricted to localhost development origins only (`localhost/127.0.0.1` on common UI ports). This is a security baseline to avoid drive-by browser calls.

If you run frontend and API on a different remote origin, you must **modify `services/api/main.py`** and add your exact origin(s) to `allow_origins` in the `CORSMiddleware` config.  
Do not use wildcard origins in production.

Primary integration endpoints:

- Health check: `GET /health`
- Projects: `POST /projects`, `GET /projects/{project_id}`, `PATCH`, `DELETE`
- Profile: `POST /projects/{project_id}/profiles`, `GET /projects/{project_id}/profiles/{name}`
- Tool: `POST /projects/{project_id}/tools`, `GET /projects/{project_id}/tools/{tool_name}`
- Skill: `POST /projects/{project_id}/skills:upload`, `GET /projects/{project_id}/skills`
- Agent: `GET /projects/{project_id}/agents`, `POST /projects/{project_id}/agents`
- Card/box queries: `GET /projects/{project_id}/cards/{card_id}`, `/cards/batch`, `/boxes/{box_id}`, `/boxes/batch`
- Streamed/state subscription result reading: typically via NATS `evt`/`str`, not additional HTTP push endpoints

Optional test/debug endpoint:

- `POST /projects/{project_id}/god/pmo/{tool_name}:call` (controlled by `CG_ENABLE_GOD_API`)

## 3.2 NATS Boundary (Read `docs/EN/04_protocol_l0/nats_protocol.md` First)

Subject conventions are centrally generated by `core/subject.py`:

```python
cg.{ver}.{project_id}.{channel_id}.{category}.{component}.{target}.{suffix}
```

Key directions for external integration:

- `cmd` / `evt`: JetStream, use `subscribe_cmd` + `publish_event`
  - `services/pmo/service.py`, `services/agent_worker/loop.py`, `services/ui_worker/loop.py`
- `str`: Core NATS, use `subscribe_core` + `publish_core`
  - Example subscription: `cg.v1r3.{project}.{channel}.str.agent.{agent_id}.chunk`

`NATSClient` automatically creates default streams:

- `cg_cmd_{v1r3}`
- `cg_evt_{v1r3}`

### Subscribe / Publish Recommendations (External Boundary)

- External tool services:
  - Subscribe to: `cg.{v1r3}.{project}.{channel}.cmd.tool.{target}.*`
  - Reply by writing `tool.result` cards in the tool callback and flow back through the L0 report path to `state.agent_inbox`
- External UI/event consumers:
  - Subscribe to `evt.agent.{agent_id}.task/step/state` and `str.agent.{agent_id}.chunk`
- External control entry:
  - Trigger external behavior through API or `cmd.sys.ui.action` (consumed by UI-related services)

### Headers and Visibility Constraints (Aligned with Implementation)

`infra/nats_client.py` `publish_event` automatically injects:

- `traceparent` (auto-generated if missing)
- `CG-Timestamp`
- `CG-Version`
- `CG-Msg-Type`
- `CG-Sender`

The implementation still requires explicit header handling on the `cmd` / `evt` protocol chain:

- `CG-Recursion-Depth` (see `core/headers.py`)
- Traceparent propagation and callback-context consistency for `tool`

Prefer generating call headers through `core.trace.ensure_trace_headers` + `core.headers.ensure_recursion_depth`, then passing them to `publish_event`.

## 3.3 CardBox Boundary (Persistent State)

`infra/cardbox_client.py` provides production-ready async interfaces:

- `CardBoxClient(config=...).init()/close()`
- `save_card`/`get_cards`/`save_box`/`get_box`/`append_to_box`, etc.
- All external reads/writes use `core.utp_protocol.Card` as the semantic model.

For external writes, prefer standard content:

- `ToolCallContent`, `ToolResultContent`
- `ToolCommandPayload` (for tool callback/call parameter validation, see `core.utp_protocol.py`)

## 4. Recommended External Tool Service Integration Template (Aligned with Existing Services)

### Minimal Responsibilities

1. Load unified configuration via `load_app_config`
2. Initialize `NATSClient` + `CardBoxClient` (call `NATSClient.connect()` / `CardBoxClient.init()` as needed)
3. `subscribe_cmd` to your own `cmd.tool.<target>.*` subject
4. Read the `tool.call` Card by `tool_call_card_id`
5. Write `tool.result` Card and trigger execution boundary through the return path after execution

### Reference Implementation Style

- Connection and subscription style: `services/tools/mock_search.py`
- Tool service startup method: `main()` in `services/tools/openapi_service.py`
- Tool payload validation: `core.utp_protocol.ToolCommandPayload`

> Note: The recommended return path for tool receipts in this repository is "write card + report + wakeup", not publishing `cmd.agent.*.tool_result` again at the business semantic layer.

## 5. Items That Differ from Current Repository Code (Why This Page Was Revised)

- Removed inconsistent content from old generic install examples and outdated example scripts.
- Added `CG__` environment variable overrides, `CG_CONFIG_TOML`, and `PG_DSN` compatibility overrides.
- Updated event boundaries from a single `subscribe_core/evt` example to full `cmd` / `evt` + `str` dual-channel explanation.
- Aligned Management API boundaries (endpoints and startup flow) with the actual implementation in `services/api/main.py`.
- Completed `tool result` return-flow mechanism and external constraints for `recursion depth` / `trace`.
