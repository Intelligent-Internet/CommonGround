# PMO Context Handling (Context Packing / Handover)

This document belongs to the L1 kernel layer and describes how PMO currently assembles the `context_box_id` for downstream `AgentTurn`s. This is also the current entry point for cross-Agent shared context and an extension point (new packing strategies can be added via internal handler + handover configuration).

## 1. Core Mental Model (P0)

- **Centralized storage is not default visibility**: Cards/Boxes are stored centrally in CardBox/Postgres at project scope, but a single turn's LLM only sees the `context_box_id` and that turn's `output_box_id` (`Worker` merges `output_box_id` with `context_box_id` before passing to the LLM). PMO does not automatically hydrate full project history into context.
- **`box_id` is not a security boundary (current implementation)**: at the system layer, access control based on boxes is not yet a fully enforced capability. Components with read access can access card content by `box_id`.
- **Cross-Agent sharing must be explicit**: shared context is realized by explicitly passing `box_id` and repacking the context box; there is no global implicit concatenation.

## 2. Current Components and Boundaries

- `services/pmo/handover.py::HandoverPacker.pack_context`: core context packer.
- `services/pmo/internal_handlers/orchestration_primitives.py::pack_context_with_instruction`: unified packing entry for current `delegate_async` and `fork_join` (fixed `instruction -> task.instruction`, and `meta.parent_pointer` is appended by default).
- `services/pmo/internal_handlers/delegate_async.py`: main delegation path entry, handles target resolution, source inheritance boxes, and calls the packer.
- `services/pmo/internal_handlers/fork_join.py`: assembles context per task and also goes through the same helper.
- `services/pmo/internal_handlers/launch_principal.py`: does not assemble context directly; it constructs `delegate_async` arguments and reuses the delegate path.
- `services/pmo/internal_handlers/ask_expert.py`: continues to reuse the same context assembly chain through `delegate_async`.

## 3. `pack_context` (`handover`) Assembly Rules (Current Implementation)

Function signature:

`pack_context(project_id, tool_suffix, source_agent_id, arguments, handover, conn=None)`

1) Target profile resolution

- Prefer `arguments["profile_name"]`; if absent, use `handover["target_profile_config"]["profile_name"]`.
- Resolve to `profile_box_id` via `resource_store.find_profile_by_name`; if not found, `NotFoundError` is raised.
- Validation failures/missing fields result in `BadRequestError`.

2) `pack_arguments` rules (if present)

- Iterate each item in `handover["context_packing_config"]["pack_arguments"]` (process only `dict` entries).
- If the rule's `arg_key` exists in `arguments`:
  - `as_card_type` defaults to `task.instruction` (can be overridden).
  - Copy `card_metadata`; default `role: "user"`.
  - `task.result_fields`: parameter value must be a `list`; otherwise `BadRequestError` is raised, and it is stored as `FieldsSchemaContent`.
  - Other types: `dict/list` use `JsonContent`; other types are converted to string and stored as `TextContent`.
  - `author_id` uses `tool_suffix`; `card id` is generated by `uuid6.uuid7().hex`.
- Each rule creates one card, and each card ID is appended to the pack list.

3) `inherit_context.include_boxes_from_args`

- Reads the list of parameter names specified by `handover["context_packing_config"]["inherit_context"]["include_boxes_from_args"]`.
- Each parameter value can be a single `box_id` (`str`/`int`) or a list.
- For each box, its `card_ids` are read and appended to the new context in order, with set-based deduplication preserving first occurrence.
- Missing boxes raise `NotFoundError`; invalid argument types raise `BadRequestError`.

4) `include_parent`

- When `inherit_context.include_parent` is true, a `meta.parent_pointer` card is appended with `content.parent_agent_id = source_agent_id` and `metadata.role = "system"`.

5) Return value

- Creates context box and returns `(context_box_id, target_profile_box_id, attached_card_ids)`.
- If no valid `target_profile_box_id` is formed, `BadRequestError` is raised.

## 4. Current Context Assembly Call Chain (Runtime Path)

- `launch_principal`
  - Constructs `delegate_async` arguments (`target_strategy: new`, `target_ref: profile_name`, `instruction`) then executes delegate flow.
- `delegate_async`
  - Inherits source:
    - `context_box_id` (optional);
    - if `target_strategy == "clone"`, also inherits current source `output_box_id`.
  - Validates all source boxes with `validate_box_ids_exist`.
  - Calls `pack_context_with_instruction` for unified context packing.
- `fork_join`
  - Each task may carry `context_box_id`;
  - `clone` tasks also append source `output_box_id`;
  - Calls `pack_context_with_instruction` per task.
- `ask_expert`
  - When `include_history=true`, uses current source agent's `output_box_id` as `context_box_id`, then hands off to `delegate_async`.

## 5. Fixed recipe of `pack_context_with_instruction`

Current handover config unified by `orchestration_primitives.py`:

- `pack_arguments`: `[{"arg_key": "instruction", "as_card_type": "task.instruction"}]`
- `inherit_context.include_boxes_from_args`: `["input_box_ids"]` (only when present)
- `inherit_context.include_parent`: `True`

Thus `delegate_async/fork_join` context always includes at least:
- current `instruction` (`task.instruction`)
- cards from source boxes referenced by `inherit_box_ids`
- `meta.parent_pointer` (parent pointer)

## 6. Extensibility and Caveats

- **Extension points are in handler and handover rules**: add/modify internal handler and define custom handover in its own flow, then call `pack_context`.
- `launch_principal` does not hand-write handover; its context is reused through the `delegate_async` path and follows the above behavior.
- Output-side handling remains determined by Dispatcher/Worker; PMO does not write `output_box_id` here.

## 7. Common Misconceptions (Aligned with Current Implementation)

- "Each agent's box is private": not accurate. Privacy is a visibility policy, not physical storage isolation.
- "LLM can directly read any box_id":
  - PMO/Worker only assembles visible context for that turn; `output_box_id` is also effective only within that turn.
  - Explicit handover/inheritance is required before content becomes visible to downstream LLM.
- "channel_id fully isolates history content":
  - Current behavior is primarily control-flow and routing semantics; Cards/Boxes are still managed and accessed under `project_id`.

## 8. Related Docs

- `docs/EN/01_getting_started/architecture_intro.md` (Box visibility)
- `docs/EN/04_protocol_l0/state_machine.md` (Dual-Box constraints)
- `docs/EN/03_kernel_l1/agent_worker.md` (Worker hydration boundaries)
