# Traceability & Lineage (L0)

This document is the L0 authoritative protocol defining the minimum implementation spec for **traceability (`trace_id`)** and **cross-Agent lineage (`parent_step_id`)**. The protocol only constrains I/O and persistence semantics, and does not restrict implementation details.

---

## 1. Terminology

- **traceparent**: W3C Trace Context header (`version-traceid-spanid-flags`), containing the trace ID and parent-child call relation.
- **tracestate**: Optional extension for W3C Trace Context, carrying vendor/system custom state. It does not need to be parsed but should be transparently propagated.
- **trace_id**: `trace-id` in `traceparent` (32 hex), persisted to database and card metadata.
- **step_id**: Per-execution step ID generated by Worker and written to `state.agent_steps`.
- **parent_step_id**: Cross-Agent lineage pointer pointing to the upstream parent `step_id` that dispatched the current Agent.
- **parent_agent_turn_id/parent_turn_epoch**: Used only for scheduling return targets and gating (such as batch/fork_join), not as lineage fields.

### 1.1 Lineage and Call-Chain Responsibilities
- **Lineage primary key**: `parent_step_id` (the business-level identifier for "which step this one is derived from").
- **Call-chain primary key**: W3C `traceparent` (the observational span parent-child relation).
- **Audit reconstruction**: Reconstruct call chains using `parent_step_id + traceparent (+ execution_edges)` together; do not use `parent_turn_id` as the primary basis.

---

## 2. Header Specification

- `traceparent` is the **primary citizen**. All `cmd/evt/tool` callbacks must propagate it according to **W3C**: child spans are created and a new `traceparent` is returned by Execution primitives (**Enqueue/Report/Join**); the sender passes upstream `traceparent` as parent into the primitive and uses the primitive's returned `traceparent` when publishing externally. The `trace-id` is the chain source of truth, while `parent-span-id` is used for building the call tree.
- `tracestate` is optional passthrough (keep cross-system state; can be ignored but must not be dropped).
- `str.*` is not used as the primary reference for L0 main call chains (main chain can be derived from `traceparent` + `execution_edges`). When publishing through NATS clients, if headers are missing, a default `traceparent` will be injected.
- If upstream is missing `traceparent`, `ensure_trace_headers` and NATS publish will backfill default values; child spans are still generated by Execution primitives based on the backfilled parent `traceparent`.
- `CG-Trace-ID` has been removed and is no longer a protocol field (no compatibility path is provided).

---

## 3. Payload Specification

### 3.1 `AgentTaskPayload`
- `trace_id` is optional (generated from `traceparent.trace-id`; PMO/Worker may backfill from `traceparent` when missing).
- `parent_step_id` is optional (root dispatch may be `NULL`).

### 3.2 `Tool callbacks`
- Inbox `tool_result` must include `tool_result_card_id` and `step_id`.
- Tool callbacks should propagate/backfill `traceparent`, and inject a new `traceparent` created by the **Report** primitive (with optional `tracestate`).

---

## 4. Storage Specification

### 4.1 `state.agent_state_head`
- `parent_step_id` / `trace_id` record the lineage (parent step) and trace information for the **currently active turn**.

### 4.2 `state.agent_steps`
- Each step writes `parent_step_id` / `trace_id` (may be null).
- Each step records `tool_call_ids` (tool-call index for that step); legacy field `state.agent_turns.tool_call_ids` is no longer used.

### 4.3 `state.execution_edges`
- Execution primitives `enqueue` / `join` / `report` must persist to `state.execution_edges` and write `trace_id` / `parent_step_id` for cross-command chain traceability.
- Tool-call chains write edges with `primitive="tool_call"` (usually `edge_phase=request`) for tool-call tracing, and do not replace L0 execution primitive semantics.
- For Execution primitives, `primitive` and `edge_phase` form the sequencing semantics. `edge_phase` values are `request` / `response`.
- `source_agent_turn_id/target_agent_turn_id` are for execution routing audit, not lineage primary keys.

---

## 5. Card Metadata Specification

- Cards produced by Worker/PMO should contain:
  - `trace_id`
  - `step_id`
  - `parent_step_id` (if present)
- `tool.result` cards should usually carry `trace_id`, `parent_step_id`, and `step_id` in `metadata` (see `utp_tool_protocol.md`).

---

## 6. Propagation Rules (Minimum Implementation)

- **PMO**
  - `cmd.sys.ui.action` / `delegate_async` / `fork_join` / `launch_principal`: propagate/inject `traceparent` and `trace_id` before performing sub-scheduling.
  - `Enqueue/Join/Report`: typically write `trace_id`, and include `parent_step_id` when possible (nullable); child spans are created by the primitive, and publishing side should prefer the `traceparent` returned by the primitive.

- **Agent Worker**
  - If payload lacks `trace_id`, read and write back from `traceparent`.
  - `step_store.insert_step` writes `parent_step_id` and `trace_id` (nullable).
  - New card metadata carries `trace_id/step_id/parent_step_id`.
  - When publishing `cmd.*` / `evt.*`, prefer the `traceparent` returned by Execution primitives; non-primitive events keep existing headers and only apply `ensure_trace_headers` for missing fields when needed.

- **Tool Service**
  - Read `trace_id/parent_step_id/step_id` from `tool.call` metadata, and apply minimal backfill from headers when necessary.
  - Write `tool.result` metadata, then inject a new `traceparent` by generating a child span through the **Report** primitive.

---

## 7. Compatibility

- Existing chains may miss `parent_step_id`, but this degrades to "trace-only aggregation".
- New chains must fill fields according to this protocol to ensure traceability.
